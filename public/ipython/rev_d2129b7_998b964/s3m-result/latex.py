from converters.base import Converter
from converters.utils import markdown2latex, remove_ansi
import os
import subprocess
import sys


inkscape = 'inkscape'
if sys.platform == 'darwin':
    inkscape = '/Applications/Inkscape.app/Contents/Resources/bin/inkscape'
    if not os.path.exists(inkscape):
        inkscape = None



class  ConverterLaTeX (Converter) :
	"""Converts a notebook to a .tex file suitable for pdflatex.

    Note: this converter *needs*:

    - `pandoc`: for all conversion of markdown cells.  If your notebook only
       has Raw cells, pandoc will not be needed.

    -  `inkscape`: if your notebook has SVG figures.  These need to be
       converted to PDF before inclusion in the TeX file, as LaTeX doesn't
       understand SVG natively.

    You will in general obtain much better final PDF results if you configure
    the matplotlib backend to create SVG output with

    %config InlineBackend.figure_format = 'svg'

    (or set the equivalent flag at startup or in your configuration profile).
    """
	    inkscape = inkscape
	    extension = 'tex'
	    documentclass = 'article'
	    documentclass_options = '11pt,english'
	    heading_map = {1: r'\section',                   2: r'\subsection',                   3: r'\subsubsection',                   4: r'\paragraph',                   5: r'\subparagraph',                   6: r'\subparagraph'}
	
    def in_env(self, environment, lines):
        """Return list of environment lines for input lines

        Parameters
        ----------
        env : string
          Name of the environment to bracket with begin/end.

        lines: """
        out = [ur'\begin{%s}' % environment]
        if isinstance(lines, basestring):
            out.append(lines)
        else:  
            out.extend(lines)
        out.append(ur'\end{%s}' % environment)
        return out
	def convert(self, *args, **kwargs):
                        body = super(ConverterLaTeX, self).convert(*args, **kwargs)
        if not self.with_preamble:
            return body
                
                final = [r'%% This file was auto-generated by IPython, do NOT edit',                 r'%% Conversion from the original notebook file:',                 r'%% {0}'.format(self.infile),                 r'%%',                 r'\documentclass[%s]{%s}' % (self.documentclass_options,                                              self.documentclass),                 '',                 ]
                        myfile = os.path.realpath(__file__)
        preamble = '../preamble.tex'
        with open(os.path.join(os.path.dirname(myfile), preamble)) as f:
            final.append(f.read())

                if self.user_preamble:
            final.extend(['', '%% Adding user preamble from file:',                          '%% {0}'.format(self.user_preamble), ''])
            with open(self.user_preamble) as f:
                final.append(f.read())

                final.extend([r'\begin{document}', '',                      body,                      r'\end{document}', ''])
                return '\n'.join(final)

    
	def render_heading(self, cell):
        marker = self.heading_map[cell.level]
        return ['%s{%s}' % (marker, cell.source) ]
	def render_code(self, cell):
        if not cell.input:
            return []

        lines = [ur'\begin{codecell}']
        
        if 'source' not in self.exclude_cells:
            lines.extend(self.in_env('codeinput', self.in_env('lstlisting', cell.input)))
        
        else:
            lines.extend(self.in_env('codeinput', ''))

        outlines = []
        
        if 'output' not in self.exclude_cells:
            for output in cell.outputs:
                conv_fn = self.dispatch(output.output_type)
                outlines.extend(conv_fn(output))

            if outlines:
                lines.extend(self.in_env('codeoutput', outlines))

        lines.append(ur'\end{codecell}')

        return lines

	def _img_lines(self, img_file):
        return self.in_env('center',                [r'\includegraphics[width=6in]{%s}' % img_file, r'\par'])
	def _svg_lines(self, img_file):
        base_file = os.path.splitext(img_file)[0]
        pdf_file = base_file + '.pdf'
        subprocess.check_call([ self.inkscape, '--export-pdf=%s' % pdf_file,                               img_file])
        return self._img_lines(pdf_file)
	def render_markdown(self, cell):
        return [markdown2latex(cell.source)]
	def render_pyout(self, output):
        lines = []

                if 'latex' in output:
            lines.extend(output.latex)

        if 'text' in output:
            lines.extend(self.in_env('verbatim', output.text))

        return lines
	def render_pyerr(self, output):
                return self.in_env('traceback',                        self.in_env('verbatim',                                  remove_ansi('\n'.join(output.traceback))))
	def render_raw(self, cell):
        if self.raw_as_verbatim:
            return self.in_env('verbatim', cell.source)
        else:
            return [cell.source]
	def _unknown_lines(self, data):
        return [r'{\vspace{5mm}\bf WARNING:: unknown cell:}'] + \
          self.in_env('verbatim', data)
	def render_display_format_text(self, output):
        lines = []

        if 'text' in output:
            lines.extend(self.in_env('verbatim', output.text.strip()))

        return lines
	def render_display_format_html(self, output):
        return []
	def render_display_format_latex(self, output):
        if type(output.latex) == type([]):
            return output.latex
        return [output.latex]
	def render_display_format_json(self, output):
                return []
	def render_display_format_javascript(self, output):
                return []
	
	"""Converts a notebook to a .tex file suitable for pdflatex.

    Note: this converter *needs*:

    - `pandoc`: for all conversion of markdown cells.  If your notebook only
       has Raw cells, pandoc will not be needed.
    
    -  `inkscape`: if your notebook has SVG figures.  These need to be
       converted to PDF before inclusion in the TeX file, as LaTeX doesn't
       understand SVG natively.
    
    You will in general obtain much better final PDF results if you configure
    the matplotlib backend to create SVG output with 

    %config InlineBackend.figure_format = 'svg'

    (or set the equivalent flag at startup or in your configuration profile).
    """
	    user_preamble = None
	    exclude_cells = []


if sys.platform == 'darwin':
    inkscape = '/Applications/Inkscape.app/Contents/Resources/bin/inkscape'
    if not os.path.exists(inkscape):
        inkscape = None


